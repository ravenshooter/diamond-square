/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package TileMap;
import TileMap.Entities.Entity;
import TileMap.Entities.House;
import Tools.GV;
import Tools.Sprite;
import Tools.SpriteStore;


import java.util.ArrayList;
import java.awt.Point;
import java.awt.Rectangle;
import java.nio.FloatBuffer;
import javax.media.opengl.GL;
/**
 * Write a description of class Tile here.
 * 
 * @author (your name) 
 * @version (a version number or a date)
 */
public class Tile implements Comparable<Tile>
{
    String type;
    Sprite sprite;
    Point center;
    ArrayList <Entity> entities = new ArrayList<Entity>();
    boolean hasEntities;
    public double height;
    double distanceToCam = 0;
    boolean water;

    
    boolean showHeight = true;
    int xNr;
    int yNr;
    int xPos;
    int yPos;
    Rectangle tileRect;
    boolean markable = true; //true wenn diese Zelle markiert werden kann;
    boolean passable = true;
    boolean buildable = true;
    boolean marked;
    
    public Vertex[]corners;
    
    
    float[] color3f;
    
    /**
     * Referenzen auf die Umgebung des Tiles, 0 ist oben, dann im Uhrzeigersinn
     */
    Tile neighbours[];
    
    
    /**
     * Constructor for objects of class Tile
     */
    public Tile(TileMap tileMap, String type, int xNr, int yNr)
    {
        neighbours = new Tile[8];
        neighbours[0] = tileMap.getTile(xNr,yNr-1);
        neighbours[1] = tileMap.getTile(xNr+1,yNr-1);
        neighbours[2] = tileMap.getTile(xNr+1,yNr);
        neighbours[3] = tileMap.getTile(xNr+1,yNr+1);
        neighbours[4] = tileMap.getTile(xNr,yNr+1);
        neighbours[5] = tileMap.getTile(xNr-1,yNr+1);
        neighbours[6] = tileMap.getTile(xNr-1,yNr);
        neighbours[7] = tileMap.getTile(xNr-1,yNr-1);
        this.xNr = xNr;
        this.yNr = yNr;
        xPos = xNr*GV.get().getXTileSize();
        yPos = yNr*GV.get().getYTileSize();
        tileRect= new Rectangle(xPos,yPos,GV.get().getXTileSize(),GV.get().getYTileSize());
        center = new Point(xPos+GV.get().getXTileSize()/2,yPos+GV.get().getYTileSize()/2);
        
        
        setType(type);
        color3f = new float[3];
        corners = new Vertex[4];
        

        hasEntities =false;
        if(type.compareTo("water")==0){
            passable = false;
            buildable = false;
        }
    }
    
    /**
     * Konstuktor fuer ein black Tile ohne jeglichen Wert
     */
    public Tile(){
        this.type = "black";
        sprite = SpriteStore.get().getSprite(type+".png");
        height = 0;
        hasEntities =false;
        markable = false;
        passable = false;
    }
    
    public final void setType(String type){
        this.type = type;
        //neighbours = new Tile[8];
        //setNeighbours();
        sprite = SpriteStore.get().getSprite(type+".png");
        if(type.compareTo("water")==0){
                    passable = false;
                    buildable = false;
        }
    }
    
    

    
    

    
    public void addEntity(Entity e){
        entities.add(e);
    }
    
    
    public Entity getEntity(){
        if(entities.size() != 0){
            if(entities.get(0).getClass().getName().compareTo("Marker")!=0)
                return entities.get(0);
            else{
                if(entities.size()>0){
                    return entities.get(1);
                }else{
                    return null;
                }
            }
        }else{
            return null;
        }
    }
    
    
    public void remove(Entity e){
        int entityID = entities.indexOf(e);
        if(entityID == -1){}else{
            entities.remove(entityID);
            if(entities.size() == 0){
                hasEntities=false;
            }
        }
    }
    
    public void setHeight(double height) {
        this.height = height;
    }
    
    
    
    public void draw(GL gl) {
        gl.glBegin(GL.GL_QUADS);
        /*if(drawList[k].getType().compareTo("grass")==0) {
         gl.glColor3f(0f, 1f, 0f);
         }
         if(drawList[k].getType().compareTo("desert")==0) {
         gl.glColor3f(1f, 0f, 1f);
         }*/
        if (marked) {
            gl.glColor3f(1, 0, 0);
        }else{
            gl.glColor3fv(FloatBuffer.wrap(getColor3f()));
        }

        gl.glVertex3fv(FloatBuffer.wrap(getCornerBuffer(0)));
        gl.glVertex3fv(FloatBuffer.wrap(getCornerBuffer(1)));
        gl.glVertex3fv(FloatBuffer.wrap(getCornerBuffer(2)));
        gl.glVertex3fv(FloatBuffer.wrap(getCornerBuffer(3)));
        


        gl.glEnd();


    }
    
    public void calcDistanceToCam(Vertex v){
        distanceToCam = Math.sqrt(Math.pow(v.x-xPos,2)+Math.pow(v.y-yPos,2)+Math.pow(v.z-height,2));
    }
    
    public void setMarked(boolean marked){
        this.marked = marked;
    }
    
    public void drawEntities(GL gl){
            for(int i = 0; i < entities.size();i++){
            entities.get(i).draw(gl);
        }
    }
    
    
    /*
    public collideable isColliding(Point p){
        Entity e;
        for(int i = 0; i < entities.size();i++){
            e = entities.get(i);
            if(e instanceof collideable){
                collideable c = (collideable) e;
                if(c.isColliding(p))
                    return c; 
            }
        }
        return null;
    }
    * 
    * */

    
    public void setNeighbours(TileMap tileMap, int xNr,int yNr){
        neighbours[0] = tileMap.getTile(xNr,yNr-1);
        neighbours[1] = tileMap.getTile(xNr+1,yNr-1);
        neighbours[2] = tileMap.getTile(xNr+1,yNr);
        neighbours[3] = tileMap.getTile(xNr+1,yNr+1);
        neighbours[4] = tileMap.getTile(xNr,yNr+1);
        neighbours[5] = tileMap.getTile(xNr-1,yNr+1);
        neighbours[6] = tileMap.getTile(xNr-1,yNr);
        neighbours[7] = tileMap.getTile(xNr-1,yNr-1);
    }
    
    private void setNeighbours(){
        TileMap tileMap = GV.get().getTileMap();
        neighbours[0] = tileMap.getTile(xNr,yNr-1);
        neighbours[1] = tileMap.getTile(xNr+1,yNr-1);
        neighbours[2] = tileMap.getTile(xNr+1,yNr);
        neighbours[3] = tileMap.getTile(xNr+1,yNr+1);
        neighbours[4] = tileMap.getTile(xNr,yNr+1);
        neighbours[5] = tileMap.getTile(xNr-1,yNr+1);
        neighbours[6] = tileMap.getTile(xNr-1,yNr);
        neighbours[7] = tileMap.getTile(xNr-1,yNr-1);
    }
    
    /**
     * Returns the neighbour at the position nr, 0 is above, than clockwise, maximum 7
     * @param nr Position of the neighbour
     * @return returns null if nr > 7
     */
    public Tile getNeighbour(int nr){
        if(nr < 8){
            if(neighbours[nr]!= null)
                return neighbours[nr];
            else{
                //return new Tile();
                return null;
            }
        }else{
            return null;
        }
    }
    public void setUnpassable(){
        passable = false;
    }
    public void setUnbuildable(){
        buildable = false;
    }
    
    public void setShowHeight(boolean set){
        showHeight = set;
    }
    public int getXNr(){
        return xNr;
    }
    public int getYNr(){
        return yNr;
    }
    public int getXPos(){
        return xPos;
    }
    public int getYPos(){
        return yPos;
    }
    public Point getCenter(){
        return center;
    }
    public int getXSize(){
        return sprite.getWidth();
    }
    public int getYSize(){
        return sprite.getHeight();
    }
    public String getType(){
        return type;
    }
    public double getHeight(){
        return height;
    }
    public boolean isMarkable(){
        return markable;
    }
    
    /*
    public void setRiver(boolean river) {
        if(river = true){
            this.setColor3f(0, 0, 1);
        }else{
            this.calcColor();
        }
        this.river = river;
    }
    * */
    
    public void setColor3f(float a, float b, float c){
        float[] color = {a,b,c};
        color3f = color;
    }
    
    public synchronized Entity hasEntity(String entity){
        for(int i = 0; i < entities.size();i++){
            if(entities.get(i).getClass().getName().compareTo(entity) == 0){
                return entities.get(i);
            }
        }
        return null;
    }
    public Point getPos(){
        return new Point(xNr*GV.get().getXTileSize(),yNr*GV.get().getYTileSize());
    }
    
    public int hasNeighbour(String type){
        int amount = 0;
        for(int i = 0;i < 8; i++ ){
            if(neighbours[i].getType().compareTo(type)==0)
                amount++;
        }
        return amount;
    }
        public int hasNeighbourAtBorder(String type){
        int amount = 0;
        for(int i = 0;i < 8; i = i + 2 ){
            if(neighbours[i].getType().compareTo(type)==0)
                amount++;
        }
        return amount;
    }

    public int compareTo(Tile o) {
        if( distanceToCam < o.distanceToCam )
            return -1;
        if( distanceToCam > o.distanceToCam )
            return 1;
            
        return 0;

    }
    
    public void doSmoothCorners(){
        corners[0] = new Vertex((float)xPos,(float)yPos,(float)height);
        corners[1] = new Vertex((float)xPos,(float)yPos+GV.get().getYTileSize(),(float)getNeighbour(4).height);
        corners[2] = new Vertex((float)xPos+GV.get().getXTileSize(),(float)yPos+GV.get().getYTileSize(),(float)getNeighbour(3).height);
        corners[3] = new Vertex((float)xPos+GV.get().getXTileSize(),(float)yPos,(float)getNeighbour(2).height);        
    }
    public void doRoughCorners(){
        corners[0] = new Vertex((float)xPos,(float)yPos,(float)height);
        corners[1] = new Vertex((float)xPos,(float)yPos+GV.get().getYTileSize(),(float)height);
        corners[2] = new Vertex((float)xPos+GV.get().getXTileSize(),(float)yPos+GV.get().getYTileSize(),(float)height);
        corners[3] = new Vertex((float)xPos+GV.get().getXTileSize(),(float)yPos,(float)height);        
    
    }
    
    public float[] getCornerBuffer(int corner){
        if(corners == null){
            System.err.println(Tile.class.getPackage() + "  " + Tile.class.getName() + "    Maybe doCornerMathod not called yet.");
        }
        return corners[corner].getBuffer();
    }
    
    
    public void calcColor(){
        Triangle t = new Triangle(corners[0],corners[1],corners[2]);
        t.recalcColor();
        color3f = t.color3f;
        
    }

    public float[] getColor3f() {
        return color3f;
    }

    public void setWater() {
        water = true;
        setColor3f(0f,0f,1f);
    }

    public boolean getWater() {
        return water;
    }


    /**
     * Part of the riverable interface, returns the xNr of the tile.
     * @return xNr of the tile
     */
    public int getX() {
        return getXNr();
    }

    /**
     * Part of the riverable interface, returns the yNr of the tile.
     * @return yNr of the tile
     */
    public int getY() {
        return getYNr();
    }
    
    
    
    
    class Triangle{
        Vertex a;
        Vertex b;
        Vertex c;
        float [] color3f = new float [3];
        public Triangle(Vertex a, Vertex b, Vertex c ){
           this.a = a;
           this.b = b;
           this.c = c;
        }
        
        public void setOcean(){
            color3f[0] = (float) (0.28f + Math.random()*0.1f);
            color3f[1] = (float) (0.48f + Math.random()*0.1f);
            color3f[2] = (float) (0.8f + Math.random()*0.1f);
        }
        
        public void setBeach() {
            color3f[0] = (float) (1f - Math.random()*0.1f);
            color3f[1] = (float) (1f - Math.random()*0.1f);
            color3f[2] = (float) (0f + Math.random()*0.1f);
        }
        
        public void setForest() {
            color3f[0] = (float) (0.05f + Math.random()*0.1f);
            color3f[1] = (float) (0.4f + Math.random()*0.1f);
            color3f[2] = (float) (0f + Math.random()*0.1f);
        }
        
        public void setMountain() {
            color3f[0] = (float) (0.4f + Math.random()*0.1f);
            color3f[1] = (float) (0.4f + Math.random()*0.1f);
            color3f[2] = (float) (0.4f + Math.random()*0.1f);
        }
        
        public void setGlacier() {
            color3f[0] = (float) (1f - Math.random()*0.1f);
            color3f[1] = (float) (1f - Math.random()*0.1f);
            color3f[2] = (float) (1f - Math.random()*0.1f);
        }
        
        public void recalcColor(){
            Vertex v1 = new Vertex(c.x - a.x, c.y - a.y, c.z - a.z);
            Vertex v2 = new Vertex(b.x - a.x, b.y - a.y, b.z - a.z);
            
            Vertex vres = new Vertex(v1.y*v2.z - v1.z*v2.y,
                                     v1.z*v2.x - v1.x*v2.z,
                                     v1.x*v2.y - v1.y*v2.x);
            
            //vektor normieren
            float fac = (float) Math.sqrt(Math.pow(vres.x,2) + Math.pow(vres.y,2) + Math.pow(vres.z,2));
            vres.x /= fac;
            vres.y /= fac;
            vres.z /= fac;
            
            double p =  Math.sqrt(Math.pow(vres.x,2) + Math.pow(vres.y,2) + Math.pow(vres.z,2));
            
            Vertex vcam = new Vertex(-(float)(3/3.1),0f,(float)(1/3.1));
            
            color3f[0] = Math.abs((vcam.x*vres.x + vcam.y*vres.y + vcam.z*vres.z)*0.5f)+0.25f;
            color3f[1] = color3f[0];
            color3f[2] = color3f[0];
        }
        
    }
}

 